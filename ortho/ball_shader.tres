[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;

render_mode cull_disabled, unshaded;

uniform vec4 color: hint_color;
uniform float pixel_size: hint_range(0, 200.0) = 100.0;
uniform float circle_size: hint_range(0, 1.0) = 0.85;
uniform float fuzz_amt: hint_range(0.0, 1.0) = 0.2;
uniform float ball_size = 1.0;

float random (float x) {
    return fract(sin(x)*
        439999.5453123);
}

void fragment() {
	float pp = pixel_size * ball_size;
	vec2 bucketed_uv = trunc(UV * pp) / pp;
	float dist = distance(bucketed_uv, vec2(0.5, 0.5));
	vec4 v = FRAGCOORD;
	v.z -= 0.25;
	float random_distance = random(bucketed_uv.y) * fuzz_amt * 0.1;
	if (bucketed_uv.y > 0.1 && bucketed_uv.y < 0.9) {
		dist -= random_distance;
	}
	
	
	if (dist > 0.5 * circle_size) {
		ALPHA = 0.0;
	} else {
		ALBEDO = vec3(color.rgb) - vec3(v.z);
		ALPHA = 1.0;	
	}
	
	// Allows this to render through the opaque pipeline even though
	// it's an alpha fragment
	ALPHA_SCISSOR = 1.0;
}

void vertex() {
	// Billboard the plane
	MODELVIEW_MATRIX = INV_CAMERA_MATRIX * mat4(CAMERA_MATRIX[0],CAMERA_MATRIX[1],CAMERA_MATRIX[2],WORLD_MATRIX[3]);
}"

[resource]
resource_local_to_scene = true
shader = SubResource( 1 )
shader_param/color = Color( 0.396078, 0.533333, 0.282353, 1 )
shader_param/pixel_size = 100.0
shader_param/circle_size = 0.85
shader_param/fuzz_amt = 0.2
shader_param/ball_size = 1.2
